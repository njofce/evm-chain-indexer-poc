## General notes

1. This is a simple, unoptimized service that loads all the transactions from an EVM-based blockchain, performs base parsing of raw ETH transfer events and ERC-20 transfer events, and stores those in a database.
2. This service always loads the latest block. However, due to reorgs, an ideal situation is to load blocks with a lag based on the safe threshold for reorgs (ex. 127 blocks for Polygon, 15 blocks for Ethereum etc). This would mean that indexing a finalized transaction and making it available via the API will take a few minutes. The system can be also designed to make the transactions immediately queryable, with the risk of those getting invalidated due to reorgs.
3. The final proposed architecture is a microservice-based architecture, where the chain indexer service is the service which is supposed to be very fast and process blocks in ms time, while the actual transaction parsing is done in another, decoupled service.
4. The resilient deployment for the indexer service includes a deployment in a Kubernetes cluster, where we can run 1 pod per chain for higher throughput (with JS) or 1 pod for multiple chains with another language that supports concurrency (Go, Rust, Java). There are several considerations:
   1. The backfil (if needed) happens on startup, in parallel with processing of new blocks. However, latest block will be recorded in the database only after the backfil is complete. This process is ideal when ran in a multi threaded language.
   2. The main bottlenecks are the database and the RPC provider. An ideal scenario for resiliency is runtime-switch for RPC provider (ex. the system can support multiple RPC providers, and when one is unhealthy, it switches to another one). When the database is down, the /health endpoint, which is probed by K8 will return 500, causing the service to restart until the DB (and MQ in the HLD) is active. 
